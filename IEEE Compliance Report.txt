IEEE Compliance Report

For the full output log, please see the file "full_log_output.txt"

INTEGER OVERFLOW (generated by addition, mulitplication or similar of large no.s) is handled by as follows: 
- for additive operations ( sum = a + b ), check if ( sum - a ) returns b
- for multiplicative operations ( prod = a*b ) check if ( prod/a ) returns b
if operations resulted in an overflow, the checking function will return a true (to indicate an overflow has occured) otherwise it will return a false.

INTEGER DIVISION BY ZERO : this operation caused both systems to crash during execution

FLOATING POINT OVERFLOW : checking functionality is similar to how checking function for integer overflow works. Checking function will warn user of overflow by printing to output log. Primary difference between integer and floating point is large fp overflows to "inf", while integer overflow will result in an incorrect, but "legal" value.

OPERATIONS WITH INF AND NINF: inf values are generated by operations such as division by 0. Functions for custom detection of INF/ NINF were implemeted as follows: (1) Generate a new INF variable within the check fcn; (2) check if input argument (argin) equals INF variable and return true/ false. INF/ NINF variables behaved as per IEEE754 stipulations as described in the output log.

OPERATIONS WITH NAN: nan is generated by operations such as sqrt(-1). Fuctions for custom detection of nan were implemented as follows: (1) check if argin is equal to a rational number (e.g. 5); (2) check if argin is more than 5; (3) check if argin is less than 5. If all three checks return a false, the argin is a nan. Arithmetic operations with nan always return a nan.

SIGNED ZERO: Signed zeros are generated when arithmetic operations result in 0 (approaching from the positive side or the negative side). Checking for signed zeros was done as follows: (1) check if the absolute value of argin equals 0; (2) check if the signed bit of argin indicates + or - and return true/false appropriately. 

UNDERFLOW: The system displays gradual underflow for small numbers generated by arithmetic operations. The general trend was that underflow was generated for argins whole decimal values were more than 15 decimal places (or more) further away than the most significant digit.  Subtraction seems to display a lower degree of accuracy than division.

COMPARISON OF PERFORMANCE:
The tests were performed on a Windows Platform (with a MinGW compiler) and on a MacOS Platform (using the XCODE IDE). Both systems produced identical results in exception handling.